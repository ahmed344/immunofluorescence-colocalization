#!/usr/bin/env python3
"""Colocalization result visualization and statistical annotation pipeline.

This script reads the three CSV outputs generated by `colocalization_analysis.py`
and exports publication-ready visualizations, including:
- condition-wise boxplots
- Mann-Whitney U tests between conditions
- statannotations significance overlays
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Iterable

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from statannotations.Annotator import Annotator


# Plotting configuration models
@dataclass(frozen=True)
class PlotConfig:
    """Container for plotting and statistical configuration.

    Args:
        condition_order (list[str]): Ordered condition labels used on x-axis.
        min_samples_per_group (int): Minimum non-null samples needed per condition for statistical testing.
        multiple_testing_correction (str | None): Correction method passed to statannotations.
        palette (str): Seaborn color palette name for condition categories.
        figure_dpi (int): DPI used when exporting figures.
        boxplot_width (float): Width of seaborn boxplots.
        strip_alpha (float): Transparency for strip points.
        strip_size (float): Marker size for strip points.

    Returns:
        PlotConfig: Immutable plotting configuration.
    """

    condition_order: list[str]
    min_samples_per_group: int = 2
    multiple_testing_correction: str | None = "Bonferroni"
    palette: str = "Set2"
    figure_dpi: int = 160
    boxplot_width: float = 0.65
    strip_alpha: float = 0.6
    strip_size: float = 4.0


# Input and output paths
BASE_RESULTS_DIR = Path(
    "/workspaces/immunofluorescence-colocalization/data/Amylose fev 2026 Mac TTR Kappa Lambda/results"
)
PER_IMAGE_CSV = BASE_RESULTS_DIR / "colocalization_per_image.csv"
SUMMARY_CSV = BASE_RESULTS_DIR / "colocalization_per_condition_summary.csv"
QC_CSV = BASE_RESULTS_DIR / "colocalization_qc.csv"
VISUALIZATION_DIR = BASE_RESULTS_DIR / "visualizations"

INTENSITY_METRICS = ["pearson_r", "spearman_rho", "manders_m1", "manders_m2", "li_icq"]
TOPOLOGY_METRICS = ["jaccard_iou", "dice_f1", "border_engagement_fraction"]
SPATIAL_METRICS = ["nnd_mean_px", "nnd_median_px", "ripley_k_auc", "ripley_k_rmax", "gr_mean", "gr_peak"]

SUMMARY_METRICS = ["pearson_r", "jaccard_iou", "dice_f1", "nnd_mean_px", "ripley_k_auc", "gr_mean"]
STATS_CORRECTION_WARNING_SHOWN = False


# Plotting and statistics utilities
def ensure_output_dir(output_dir: Path) -> Path:
    """Create the visualization output directory if needed.

    Args:
        output_dir (Path): Target directory for exported figures.

    Returns:
        Path: The same output path after ensuring it exists.
    """

    output_dir.mkdir(parents=True, exist_ok=True)
    return output_dir


def load_dataframes(per_image_path: Path, summary_path: Path, qc_path: Path) -> tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    """Load the three result CSV files into dataframes.

    Args:
        per_image_path (Path): Path to per-image metrics CSV.
        summary_path (Path): Path to per-condition summary CSV.
        qc_path (Path): Path to QC status CSV.

    Returns:
        tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]: Per-image, summary, and QC dataframes.
    """

    per_image_df = pd.read_csv(per_image_path)
    summary_df = pd.read_csv(summary_path)
    qc_df = pd.read_csv(qc_path)
    return per_image_df, summary_df, qc_df


def validate_columns(df: pd.DataFrame, required_columns: Iterable[str], df_name: str) -> list[str]:
    """Validate required columns and report any missing ones.

    Args:
        df (pd.DataFrame): Dataframe to validate.
        required_columns (Iterable[str]): Required column names.
        df_name (str): Human-readable dataframe label for warnings.

    Returns:
        list[str]: Missing columns in this dataframe.
    """

    missing = [col for col in required_columns if col not in df.columns]
    if missing:
        print(f"[WARN] Missing columns in {df_name}: {missing}")
    return missing


def build_condition_order(per_image_df: pd.DataFrame) -> list[str]:
    """Build a stable condition order prioritizing known labels.

    Args:
        per_image_df (pd.DataFrame): Per-image metrics dataframe containing condition names.

    Returns:
        list[str]: Ordered condition labels for plotting and pairwise tests.
    """

    preferred = ["TTR_MAC_Pre_albumine", "AL_MAC_Kappa", "AL_MAC_Lambda"]
    present = per_image_df["condition"].dropna().astype(str).unique().tolist()
    order = [c for c in preferred if c in present]
    extra = sorted([c for c in present if c not in order])
    return order + extra


def build_condition_pairs(condition_order: list[str]) -> list[tuple[str, str]]:
    """Enumerate all unique condition pairs for pairwise testing.

    Args:
        condition_order (list[str]): Ordered condition labels.

    Returns:
        list[tuple[str, str]]: Unique condition pairs.
    """

    pairs: list[tuple[str, str]] = []
    for i in range(len(condition_order)):
        for j in range(i + 1, len(condition_order)):
            pairs.append((condition_order[i], condition_order[j]))
    return pairs


def add_mannwhitney_annotations(
    ax: plt.Axes,
    metric_df: pd.DataFrame,
    metric_name: str,
    condition_order: list[str],
    min_samples_per_group: int,
    correction: str | None,
) -> list[tuple[str, str]]:
    """Add Mann-Whitney U statistical annotations for valid condition pairs.

    Args:
        ax (plt.Axes): Matplotlib axis containing the target boxplot.
        metric_df (pd.DataFrame): Dataframe with `condition` and one metric column.
        metric_name (str): Column name of the metric to test.
        condition_order (list[str]): Ordered condition labels.
        min_samples_per_group (int): Minimum non-null observations required per condition.
        correction (str | None): Multiple testing correction method name.

    Returns:
        list[tuple[str, str]]: Pairs that were tested and annotated.
    """

    candidate_pairs = build_condition_pairs(condition_order)
    valid_pairs: list[tuple[str, str]] = []
    for c1, c2 in candidate_pairs:
        n1 = int(metric_df.loc[metric_df["condition"] == c1, metric_name].dropna().shape[0])
        n2 = int(metric_df.loc[metric_df["condition"] == c2, metric_name].dropna().shape[0])
        if n1 >= min_samples_per_group and n2 >= min_samples_per_group:
            valid_pairs.append((c1, c2))

    if not valid_pairs:
        ax.text(0.02, 0.98, "No testable pairs", transform=ax.transAxes, ha="left", va="top", fontsize=8)
        return []

    annotator = Annotator(
        ax=ax,
        pairs=valid_pairs,
        data=metric_df,
        x="condition",
        y=metric_name,
        order=condition_order,
    )
    configure_kwargs = {
        "test": "Mann-Whitney",
        "text_format": "star",
        "loc": "outside",
        "verbose": 0,
    }
    if correction is not None:
        configure_kwargs["comparisons_correction"] = correction
    global STATS_CORRECTION_WARNING_SHOWN
    try:
        annotator.configure(**configure_kwargs)
    except ImportError:
        # Fallback for environments without statsmodels.
        annotator.configure(
            test="Mann-Whitney",
            text_format="star",
            comparisons_correction=None,
            loc="outside",
            verbose=0,
        )
        if not STATS_CORRECTION_WARNING_SHOWN:
            print("[WARN] statsmodels not available: using uncorrected p-values for statannotations.")
            STATS_CORRECTION_WARNING_SHOWN = True
    annotator.apply_and_annotate()
    return valid_pairs


def plot_metric_boxplot_grid(
    per_image_df: pd.DataFrame,
    metrics: list[str],
    title: str,
    condition_order: list[str],
    plot_config: PlotConfig,
    output_path: Path,
) -> Path:
    """Plot a grid of condition-wise boxplots with Mann-Whitney annotations.

    Args:
        per_image_df (pd.DataFrame): Per-image metric dataframe.
        metrics (list[str]): Metric columns to visualize.
        title (str): Figure title string.
        condition_order (list[str]): Ordered condition labels.
        plot_config (PlotConfig): Plotting and statistical options.
        output_path (Path): Figure output path.

    Returns:
        Path: Saved figure path.
    """

    available_metrics = [m for m in metrics if m in per_image_df.columns]
    missing_metrics = [m for m in metrics if m not in per_image_df.columns]
    if missing_metrics:
        print(f"[WARN] Missing metrics for {title}: {missing_metrics}")

    if not available_metrics:
        raise ValueError(f"No available metrics to plot for {title}.")

    n_metrics = len(available_metrics)
    n_cols = 3
    n_rows = int(np.ceil(n_metrics / n_cols))
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(5.3 * n_cols, 4.7 * n_rows), squeeze=False)
    ax_list = axes.ravel()

    for idx, metric_name in enumerate(available_metrics):
        axis = ax_list[idx]
        metric_df = per_image_df[["condition", metric_name]].copy()
        metric_df = metric_df.dropna(subset=[metric_name])
        metric_df = metric_df[metric_df["condition"].isin(condition_order)]

        sns.boxplot(
            data=metric_df,
            x="condition",
            y=metric_name,
            hue="condition",
            order=condition_order,
            palette=plot_config.palette,
            width=plot_config.boxplot_width,
            ax=axis,
            fliersize=0,
            dodge=False,
        )
        if axis.get_legend() is not None:
            axis.get_legend().remove()
        sns.stripplot(
            data=metric_df,
            x="condition",
            y=metric_name,
            order=condition_order,
            color="black",
            alpha=plot_config.strip_alpha,
            size=plot_config.strip_size,
            jitter=0.22,
            ax=axis,
        )

        add_mannwhitney_annotations(
            ax=axis,
            metric_df=metric_df,
            metric_name=metric_name,
            condition_order=condition_order,
            min_samples_per_group=plot_config.min_samples_per_group,
            correction=plot_config.multiple_testing_correction,
        )

        # Keep subplots clean: metric name is already visible on y-axis.
        axis.set_title("")
        axis.set_xlabel("")
        axis.tick_params(axis="x", rotation=20)
        axis.grid(alpha=0.2, axis="y")

    for idx in range(n_metrics, len(ax_list)):
        fig.delaxes(ax_list[idx])

    fig.suptitle(title, fontsize=14)
    fig.tight_layout(rect=(0, 0, 1, 0.98))
    fig.savefig(output_path, dpi=plot_config.figure_dpi)
    plt.close(fig)
    return output_path


def plot_qc_overview(qc_df: pd.DataFrame, per_image_df: pd.DataFrame, output_path: Path) -> Path:
    """Plot QC status counts and per-condition sample counts.

    Args:
        qc_df (pd.DataFrame): QC dataframe including `status` and `condition`.
        per_image_df (pd.DataFrame): Per-image dataframe including `condition`.
        output_path (Path): Figure output path.

    Returns:
        Path: Saved figure path.
    """

    fig, axes = plt.subplots(1, 2, figsize=(12, 4.5))

    status_counts = qc_df["status"].value_counts(dropna=False).rename_axis("status").reset_index(name="count")
    sns.barplot(data=status_counts, x="status", y="count", color="#4c72b0", ax=axes[0])
    axes[0].set_title("QC status counts")
    axes[0].set_xlabel("status")
    axes[0].set_ylabel("count")
    axes[0].grid(alpha=0.2, axis="y")

    cond_counts = per_image_df["condition"].value_counts().rename_axis("condition").reset_index(name="n_pairs")
    sns.barplot(data=cond_counts, x="condition", y="n_pairs", hue="condition", palette="Set2", legend=False, ax=axes[1])
    axes[1].set_title("Pair counts per condition")
    axes[1].set_xlabel("condition")
    axes[1].set_ylabel("n_pairs")
    axes[1].tick_params(axis="x", rotation=20)
    axes[1].grid(alpha=0.2, axis="y")

    fig.tight_layout()
    fig.savefig(output_path, dpi=160)
    plt.close(fig)
    return output_path


def plot_metric_correlation_heatmap(per_image_df: pd.DataFrame, metric_columns: list[str], output_path: Path) -> Path:
    """Plot a correlation heatmap for selected numeric metrics.

    Args:
        per_image_df (pd.DataFrame): Per-image metrics dataframe.
        metric_columns (list[str]): Metrics to include in correlation matrix.
        output_path (Path): Figure output path.

    Returns:
        Path: Saved figure path.
    """

    available = [m for m in metric_columns if m in per_image_df.columns]
    corr_df = per_image_df[available].corr(numeric_only=True)

    fig, ax = plt.subplots(figsize=(12, 10))
    sns.heatmap(corr_df, cmap="vlag", center=0.0, square=True, linewidths=0.3, cbar_kws={"shrink": 0.8}, ax=ax)
    ax.set_title("Metric correlation heatmap")
    fig.tight_layout()
    fig.savefig(output_path, dpi=160)
    plt.close(fig)
    return output_path


def plot_condition_summary(summary_df: pd.DataFrame, base_metrics: list[str], output_path: Path) -> Path:
    """Plot condition-level means with standard deviation error bars.

    Args:
        summary_df (pd.DataFrame): Condition summary dataframe with `*_mean` and `*_std`.
        base_metrics (list[str]): Base metric names to visualize from summary columns.
        output_path (Path): Figure output path.

    Returns:
        Path: Saved figure path.
    """

    available = [m for m in base_metrics if f"{m}_mean" in summary_df.columns and f"{m}_std" in summary_df.columns]
    if not available:
        raise ValueError("No valid summary metrics found for condition-level errorbar plot.")

    n_cols = 3
    n_rows = int(np.ceil(len(available) / n_cols))
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(5.0 * n_cols, 4.3 * n_rows), squeeze=False)
    ax_list = axes.ravel()

    for idx, metric in enumerate(available):
        axis = ax_list[idx]
        mean_col = f"{metric}_mean"
        std_col = f"{metric}_std"

        x = np.arange(summary_df.shape[0], dtype=int)
        y = summary_df[mean_col].to_numpy(dtype=float)
        e = summary_df[std_col].to_numpy(dtype=float)
        labels = summary_df["condition"].astype(str).tolist()

        axis.bar(x, y, yerr=e, color=sns.color_palette("Set2", n_colors=len(x)), capsize=4)
        axis.set_xticks(x)
        axis.set_xticklabels(labels, rotation=20)
        axis.set_title(metric)
        axis.grid(alpha=0.2, axis="y")

    for idx in range(len(available), len(ax_list)):
        fig.delaxes(ax_list[idx])

    fig.suptitle("Condition-level summary (mean +/- std)", fontsize=14)
    fig.tight_layout(rect=(0, 0, 1, 0.98))
    fig.savefig(output_path, dpi=160)
    plt.close(fig)
    return output_path


def print_data_quality_report(per_image_df: pd.DataFrame, qc_df: pd.DataFrame, key_metrics: list[str]) -> None:
    """Print compact data quality checks for the result tables.

    Args:
        per_image_df (pd.DataFrame): Per-image metrics dataframe.
        qc_df (pd.DataFrame): QC dataframe with status labels.
        key_metrics (list[str]): Metrics used for missing-value checks.

    Returns:
        None: Prints quality information to stdout.
    """

    print("=== Data quality report ===")
    print("Rows in per-image table:", len(per_image_df))
    print("Rows in QC table:", len(qc_df))
    print("\nQC status counts:")
    print(qc_df["status"].value_counts(dropna=False).to_string())
    print("\nPairs per condition:")
    print(per_image_df["condition"].value_counts(dropna=False).to_string())
    print("\nMissing values (selected metrics):")
    missing = per_image_df[key_metrics].isna().sum().sort_values(ascending=False)
    print(missing.to_string())


def main() -> list[Path]:
    """Run full visualization export pipeline.

    Args:
        None: Uses module-level path constants and metric groups.

    Returns:
        list[Path]: Saved figure paths.
    """

    sns.set_theme(style="whitegrid", context="notebook")
    output_dir = ensure_output_dir(VISUALIZATION_DIR)
    per_image_df, summary_df, qc_df = load_dataframes(PER_IMAGE_CSV, SUMMARY_CSV, QC_CSV)

    validate_columns(per_image_df, ["condition", "pair_id"] + INTENSITY_METRICS + TOPOLOGY_METRICS + SPATIAL_METRICS, "per-image")
    validate_columns(summary_df, ["condition"], "summary")
    validate_columns(qc_df, ["condition", "pair_id", "status"], "qc")

    condition_order = build_condition_order(per_image_df)
    plot_config = PlotConfig(condition_order=condition_order)

    all_key_metrics = INTENSITY_METRICS + TOPOLOGY_METRICS + SPATIAL_METRICS
    print_data_quality_report(per_image_df=per_image_df, qc_df=qc_df, key_metrics=[m for m in all_key_metrics if m in per_image_df.columns])

    saved_paths: list[Path] = []
    saved_paths.append(plot_qc_overview(qc_df=qc_df, per_image_df=per_image_df, output_path=output_dir / "qc_overview.png"))
    saved_paths.append(
        plot_metric_boxplot_grid(
            per_image_df=per_image_df,
            metrics=INTENSITY_METRICS,
            title="Intensity metrics by condition (Mann-Whitney U + Bonferroni)",
            condition_order=condition_order,
            plot_config=plot_config,
            output_path=output_dir / "intensity_boxplots_mannwhitney.png",
        )
    )
    saved_paths.append(
        plot_metric_boxplot_grid(
            per_image_df=per_image_df,
            metrics=TOPOLOGY_METRICS,
            title="Topological metrics by condition (Mann-Whitney U + Bonferroni)",
            condition_order=condition_order,
            plot_config=plot_config,
            output_path=output_dir / "topology_boxplots_mannwhitney.png",
        )
    )
    saved_paths.append(
        plot_metric_boxplot_grid(
            per_image_df=per_image_df,
            metrics=SPATIAL_METRICS,
            title="Spatial metrics by condition (Mann-Whitney U + Bonferroni)",
            condition_order=condition_order,
            plot_config=plot_config,
            output_path=output_dir / "spatial_boxplots_mannwhitney.png",
        )
    )
    saved_paths.append(
        plot_metric_correlation_heatmap(
            per_image_df=per_image_df,
            metric_columns=all_key_metrics,
            output_path=output_dir / "metric_correlation_heatmap.png",
        )
    )
    saved_paths.append(
        plot_condition_summary(
            summary_df=summary_df,
            base_metrics=SUMMARY_METRICS,
            output_path=output_dir / "condition_summary_errorbars.png",
        )
    )

    print("\n=== Saved visualization files ===")
    for path in saved_paths:
        print(path)
    return saved_paths


if __name__ == "__main__":
    main()
